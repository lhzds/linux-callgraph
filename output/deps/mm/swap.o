mm/swap.o
__folio_batch_release -> (lru_add_drain_cpu, release_pages, mlock_drain_local)
__folio_put -> (__folio_put_large, __page_cache_release, free_unref_page)
__folio_put_large -> (destroy_large_folio, __page_cache_release, folio_test_hugetlb)
__lru_add_drain_all -> (mutex_lock, lru_add_drain_per_cpu, mutex_unlock, queue_work_on, flush_work, need_mlock_drain, has_bh_in_lru)
__page_cache_release -> (__mod_zone_page_state, _raw_spin_lock_irqsave, mod_zone_page_state, _raw_spin_unlock_irqrestore, __mod_node_page_state)
__traceiter_mm_lru_activate -> (__traceiter_mm_lru_activate, __probestub_mm_lru_activate, __SCT__tp_func_mm_lru_activate)
__traceiter_mm_lru_insertion -> (__traceiter_mm_lru_insertion, __SCT__tp_func_mm_lru_insertion, __probestub_mm_lru_insertion)
deactivate_file_folio -> (folio_batch_move_lru, lru_deactivate_file_fn)
folio_activate -> (folio_batch_move_lru, folio_activate_fn)
folio_activate_fn -> (__mod_zone_page_state, __probestub_mm_lru_activate, __traceiter_mm_lru_activate, __mod_node_page_state, __SCT__tp_func_mm_lru_activate)
folio_add_lru -> (folio_batch_move_lru, lru_add_fn)
folio_add_lru_vma -> (mlock_new_folio, folio_batch_move_lru, lru_add_fn)
folio_batch_move_lru -> (release_pages, lru_add_fn, _raw_spin_lock_irqsave, _raw_spin_unlock_irqrestore)
folio_deactivate -> (folio_batch_move_lru, lru_deactivate_fn)
folio_mark_accessed -> (workingset_activation, folio_activate)
folio_mark_lazyfree -> (folio_batch_move_lru, lru_lazyfree_fn)
folio_rotate_reclaimable -> (folio_batch_move_lru, lru_move_tail_fn)
lru_add_drain -> (lru_add_drain_cpu, mlock_drain_local)
lru_add_drain_all -> (__lru_add_drain_all)
lru_add_drain_cpu -> (lru_add_fn, lru_lazyfree_fn, lru_deactivate_file_fn, lru_deactivate_fn, lru_move_tail_fn, folio_batch_move_lru, folio_activate_fn)
lru_add_drain_cpu_zone -> (lru_add_drain_cpu, mlock_drain_local, drain_local_pages)
lru_add_drain_per_cpu -> (lru_add_drain_cpu, invalidate_bh_lrus_cpu, mlock_drain_local)
lru_add_fn -> (__mod_zone_page_state, __traceiter_mm_lru_insertion, folio_mapping, __SCT__tp_func_mm_lru_insertion, __rcu_read_lock, __probestub_mm_lru_insertion, __mod_node_page_state, __rcu_read_unlock)
lru_cache_disable -> (__lru_add_drain_all, synchronize_rcu_expedited)
lru_deactivate_file_fn -> (__mod_zone_page_state, __mod_node_page_state)
lru_deactivate_fn -> (__mod_zone_page_state, __mod_node_page_state)
lru_lazyfree_fn -> (__mod_zone_page_state, __mod_node_page_state)
lru_move_tail_fn -> (__mod_zone_page_state, __mod_node_page_state)
lru_note_cost -> (node_page_state, _raw_spin_lock_irq, _raw_spin_unlock_irq)
lru_note_cost_refault -> (lru_note_cost)
perf_trace_mm_lru_activate -> (perf_trace_buf_alloc, perf_trace_run_bpf_submit)
perf_trace_mm_lru_insertion -> (perf_trace_buf_alloc, perf_trace_run_bpf_submit)
put_pages_list -> (free_unref_page_list, destroy_large_folio, __page_cache_release, folio_test_hugetlb)
release_pages -> (free_unref_page_list, folio_test_hugetlb, __mod_zone_page_state, zone_stat_sub_folio, _raw_spin_lock_irqsave, _raw_spin_unlock_irqrestore, __mod_node_page_state, destroy_large_folio, __page_cache_release)
trace_event_raw_event_mm_lru_activate -> (trace_event_buffer_reserve, __trace_trigger_soft_disabled, trace_event_buffer_commit)
trace_event_raw_event_mm_lru_insertion -> (trace_event_buffer_reserve, __trace_trigger_soft_disabled, trace_event_buffer_commit)
trace_raw_output_mm_lru_activate -> (trace_handle_return, trace_raw_output_prep, trace_event_printf)
trace_raw_output_mm_lru_insertion -> (trace_handle_return, trace_raw_output_prep, trace_event_printf)
zone_stat_sub_folio -> (mod_zone_page_state)
